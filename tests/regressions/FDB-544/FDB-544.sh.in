#!/usr/bin/env bash
# I think the following:
# - if there are no readable roots, it should error
# - - But the error should not be "no writable roots", because that is confusing on read.
# - if there are some unreadable roots, it should ignore them and find the next readable one


set -eux

fdbread="$<TARGET_FILE:fdb-read>"
fdbwrite="$<TARGET_FILE:fdb-write>"
fdblist="$<TARGET_FILE:fdb-list>"
fdbwipe="$<TARGET_FILE:fdb-wipe>"
gribcount="$<TARGET_FILE:grib_count>"

srcdir=@CMAKE_CURRENT_SOURCE_DIR@
bindir=@CMAKE_CURRENT_BINARY_DIR@

export FDB_HOME=$bindir
# export FDB_DEBUG=0
# export ECKIT_DEBUG=0

for f in config.yaml schema *.grib
do
    cp $srcdir/$f $bindir
done

request_base="class=od,date=20230508,domain=g,levtype=sfc,param=151130,step=1,stream=oper,time=1200,type=fc"
request_xxxx="$request_base,expver=xxxx"
request_xxxy="$request_base,expver=xxxy"
config="config.yaml"

cleanup() {
  # --- cleanup ---

  # nasty to leave 000 permissions behind
  chmod 755 ${bindir}/root_xxxy || true
  chmod 755 ${bindir}/root_xxxx || true
  chmod 755 ${bindir}/root_unreadable || true

  rm -rf ${bindir}/root_xxxx
  rm -rf ${bindir}/root_xxxy
  rm -rf ${bindir}/root_unreadable
  rm -f ${bindir}/out_*.grib
}
trap cleanup EXIT # Ensure cleanup is called when the script exits

cleanup
mkdir -p ${bindir}/root_xxxx
mkdir -p ${bindir}/root_xxxy
mkdir -p ${bindir}/root_unreadable
mkdir -p ${bindir}/root_readable

chmod 000 ${bindir}/root_unreadable # explicitly always unreadable

export FDB5_CONFIG_FILE=$bindir/$config

$fdbwrite xxxx.grib xxxy.grib

# Ensure both are written
nlist=$($fdblist $request_base --porcelain --minimum-keys="" | wc -l)
[[ $nlist -ne 2 ]] && { echo "Error: expected 2 items in list, got $nlist"; exit 1; }


# --- XXXX unreadable ---
chmod 000 ${bindir}/root_xxxx

# list, expect 1
nlist=$($fdblist $request_base --porcelain --minimum-keys=""  | wc -l)
[[ $nlist -ne 1 ]] && { echo "Error: expected 1 items in list, got $nlist"; exit 1; }

# read, should find xxxy, but not xxxx
$fdbread <(echo "retrieve,$request_base,expver=xxxx") out_xxxx.grib # expect 0 byte file
$fdbread <(echo "retrieve,$request_base,expver=xxxy") out_xxxy.grib # should work

size_xxxx=$(wc -c < out_xxxx.grib)
[[ $size_xxxx -ne 0 ]] && { echo "Error: expected out_xxxx.grib to have 0 bytes, got $size_xxxx"; exit 1; }
diff out_xxxy.grib xxxy.grib


# --- XXXX and XXXY unreadable ---
chmod 000 ${bindir}/root_xxxy

# list, expect 0
nlist=$($fdblist $request_base --porcelain --minimum-keys=""  | wc -l)
[[ $nlist -ne 0 ]] && { echo "Error: expected 0 items in list, got $nlist"; exit 1; }

# read, should not find xxxx nor xxxy
$fdbread <(echo "retrieve,$request_base,expver=xxxx") out_xxxx.grib # expect 0 byte file
$fdbread <(echo "retrieve,$request_base,expver=xxxy") out_xxxy.grib # expect 0 byte file. maybe should error?

size_xxxx=$(wc -c < out_xxxx.grib)
[[ $size_xxxx -ne 0 ]] && { echo "Error: expected out_xxxx.grib to have 0 bytes, got $size_xxxx"; exit 1; }
size_xxxy=$(wc -c < out_xxxy.grib)
[[ $size_xxxy -ne 0 ]] && { echo "Error: expected out_xxxy.grib to have 0 bytes, got $size_xxxy"; exit 1; }


# --- XXXY unreadable ---
chmod 755 ${bindir}/root_xxxx

# list, expect 1
nlist=$($fdblist $request_base --porcelain --minimum-keys=""  | wc -l)
[[ $nlist -ne 1 ]] && { echo "Error: expected 1 items in list, got $nlist"; exit 1; }

# read, should find xxxx, but not xxxy
$fdbread <(echo "retrieve,$request_base,expver=xxxx") out_xxxx.grib  # should work
$fdbread <(echo "retrieve,$request_base,expver=xxxy") out_xxxy.grib # expect 0 byte file. maybe should error?

diff out_xxxx.grib xxxx.grib
size_xxxy=$(wc -c < out_xxxy.grib)
[[ $size_xxxy -ne 0 ]] && { echo "Error: expected out_xxxy.grib to have 0 bytes, got $size_xxxy"; exit 1; }

echo "done"
